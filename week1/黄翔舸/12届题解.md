### 1

从1开始每到一个数就将其每一位对应的卡片个数减1，直到不能减了为止。

### 2

用起设套双，根据y=kx+b，记录k+b并插入到起设中，因为起设是中是没有重复的。在枚举的时候要排除横坐标相同或纵坐标相同的情况，因为会有重复的，而且有的不能求k。最后输出s.size（）+41（41是平行x轴或y轴的线的个数）。

### 3

找三个相乘等于n的数x、y、z，为了方便令x<=y<=z。所以x范围是1-\sqrt[n]{3},y的范围是1-\sqrt{n}，z的范围是1-n;在循环的时候判断是不是x<=y<=z来去重。然后判断其中有没有相等的，因为这三个可以任意交换位置。三个相等+1，有两个相等+3，都不相等+6.

### 4

dp【1】=0，先用1来更新其他的路径。每到一个i点，就从该点往后循环点j，来更新j点的值。dp【j】=min（dp【j】，dp【i】+i，j路径长度）。路径长度可以用i\*j/gcd（i，j）求出。另外需要注意约数j-i<=21.

### 5

对应题目要求操作：1.取出整数n在二进制表示下的第k位（n>>k）&1 。2.取出整数n在二进制表示下的第0-k-1位n&（（1<<k)-1)。3.把整数n在二进制表示下的第k位取反n xor（1<<k) .4.对整数n在二进制表示下的第k为赋值为1 n|（1<<k) 。5.对整数n在二进制表示下的第k为赋值0 n&(~(1<<k))

这个题用dp，二进制数i，在某一位上0表示未经过，1表示经过。用gcd（i，j）判断i和j之间是否连通，先预处理出来。首先f【i】【j】表示状态为i且当前点为j的路的个数。首先初始化f【2】【1】=1.（第一位可以表示0故从第二位开始）。第一层循环i即状态，从2到1<<22-2（最后统计1<<22-1的状态数，故不在循环列中）第二层j表示每一个点。然后判断一下第j位的点是否为1即是否经过了第j位，如果经过就进入第三层循环k，k代表点数，要保证没有经过j点其他位都一样并且k与j之前连接，这样才能把经过k点的路径数加到f【i】【j】上。最后加和f【1<<22-1】【每一个点】的数即为所求。

### 6

还是dp，dp【i】【j】表示用了前i个砝码是否可以表示j的重量。（不一定都要用且dp为bool型），dp【i】【j】=dp【i-1】【j】，如果还是等于0，就再判断，1.判断j是否等于a【i】。2.判断放在同侧是否等于j。3.判断放在异侧是否等于j，因为每一次j都循环sum，所以不会有漏的情况。

### 7

题目要求1^0=1 1^1=0 0^0=0 将每一个数转换成二进制记录每一位1的个数。如果最高位1位奇数且n为奇数，则先手赢，否则后手赢。如果是偶数，看下一位就行了。