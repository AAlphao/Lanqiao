1.方程整数解

按照题目要求暴力采用三层FOR循环枚举带入A,B,C,的值进行计算即可。

for(int i=1;i<=500;i++)
	{
		for(int j=1;j<=500;j++)
		{
			for(int k=1;k<=500;k++)
			{
				if((i*i+j*j+k*k)==1000)
				{
					cout<<i<<endl;
				}
			}
		}
	}







2.星系炸弹

直接手算更快，注意有31天的月份和闰年366天即可。







3.奇妙的数字

先大概判断这个数在40-100之间（因为40*40=1600，4位；40的立方=64000，5位），所以直接暴力枚举40-100间的所有结果，观察即可。







4.牌型种数

排列组合问题。因为不考虑花色，所以没次在1-13中选一张牌。注意：同一点数的牌只有四张。

所以答案为：

case1：6张都不同C13 6；

case2:   5张不同C13 5*C5 1；

.....

最后将所有结果加起来就是答案。







5，这道题直接用排列组合不好计算，不妨采用字符串用a,b,c分别代表三种颜色，采用next_permutation生成全排列，然后按照题目要求进行去重，最后输出ANS即可。







6.饮料换购

基础题，按照题意模拟即可。

核心代码：
while(a>=3)
	{
		ans=ans+a/3;
		a=a%3+a/3;
	}

最后输出ANS即可。







7，垒骰子

不会，参考网上题解后发现是DP+矩阵快速幂。

`dp[i][j]` 代表高度为`i`，顶面点数为`j`的方案数，于是 `dp[i][j]` 就等于`i-1`高度时所有与j对面无冲突方案数的累加。

当然，最下面一层所有面在上的方案数都为1，求得结果后还要乘以 `4^i` ，因为每一个骰子都可以保证顶端点数不变的情况下四面旋转。







8.本人写法采用最小生成树（kruskal ）结果超时被卡。

正解：采用最小生成树（kruskal ）+倍增的方法进行计算。

或最小生成树（kruskal ）+并查集。

我们按照Kruskal算法的思想，依次选择边，如果该边加进去之后能够使得我们想要连通的点全部连通，那么我们就输出该条边的权值。