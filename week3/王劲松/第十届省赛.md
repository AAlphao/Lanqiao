# F完全二叉树的权值

每层加起来比较

# G外卖店优先级

先按时间排序订单，模拟每个时间，先全部减一，有订单的加回来然后加上订单数*2

# H修改数组

标记出现过的数，每次都检查。（这样只能拿90，拿满分要用到并查集）

# I糖果

不会。。参考网上要用状态压缩dp

（1）定义状态d p [ i ]，表示得到口味组合 i 所需要的最少糖果包数量。

（2）状态如何转移？往口味组合 i 中加入一包糖果，设得到新的口味组合 j ，说明从 i 到 j 需要糖果包数量d p [ i ] + 1 。若原来的d p [ j ] 大 于 d p [ i ] + 1，说明原来得到 j 的方法不如现在的方法，更新d p [ j ] = d p [ i ] + 1。

例如一包里面有3颗糖果，分别是“2，3，5”三种口味，用二进制数“10110”表示，二进制数的每一位表示一种口味。

（以上参考网络）

# J组合数问题

完全不会，参考网上：

对于这题我们需要用到卢卡斯定理。将n和m都转化为p进制数。

根据卢卡斯定理，如果模k为0，那么n的p进制中的存在一数位小于m中对应数位上的值即可。

但计算至少存在一个这种终归很麻烦，所以还是要用到正难则反的思想。

我们求出n和m的组合数总数，再减去n中每一数位都大于m的数量。即可得到答案。

求n中每一数位都大于m的数量我们可以用到数位DP。

先定义4种状态：

dp[i][0] :表示前i位n和m都没限制的数量

dp[i][1] :n的前i位都有限制，m前i位都无限制

dp[i][2] :m的前i位都有限制，n的前i位都无限制

dp[i][3] :n，m的前i位都有限制

再定义3个函数：

calc(x,y)：x取值[0, x], y取值[0,y]，x >=y的数量

calc1(x,y)：x固定，y取值为[0,y] ，x >= y的数量

calc2x,y)：y固定，x取值为[0,x] ，x >= y的数量

最后状态转移方程：

dp[i][0] = dp[i+1][0] * calc(P-1, P-1) + dp[i+1][1] * calc(a[i]-1, P-1) + dp[i+1][2] * calc(P-1, b[i]-1) + dp[i+1][3] * calc(a[i]-1, b[i]-1);